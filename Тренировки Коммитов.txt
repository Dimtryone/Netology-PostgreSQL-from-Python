https://github.com/netology-code/guides/blob/master/git-basics/git%20Addition%20materials%20lesson%202.md

Документация
https://git-scm.com/docs/git-branch/2.21.0


Команды GIT


git --version для получения актуальной версии

git config 

Проверить все установленные настройки   
git config --list --show-origin

Задать юзера и е-майл.
git config --global user.name "Петр Петров"
git config --global user.email petrov_p@netology.ru
Задать редактор
git config --global core.editor <редактор>

Получение справки по команде GIT, выйти обратно клавиша 'q'
git help clone
man git clone
git clone -h

При инициализации создается имя master,можно изменить имя ветки
git config --global init.defaultBranch main

Создание GIT
 git init

Добавление файла в репозиторий
git add <name_file>
git add *
git add *.js
Для проверки статуса репозитория
git status
Фиксация изменения в файле
git commit

Сокращенная команда для добавления файла и внесения комментарий
git commit -a -m "Комментарий"
-a --all
-m --message

История изменения проекта отобразит Кто, Когда внес изменения, commit: Хеш-Суммa.
git log     Конкретно, что изменилось
git show <hesh-summa>  - зеленным покажет изменения

Удалить случайно добавленный файл
git rm --cashed <путь\имя файла>
git rm --cashed -r <catalog>  - удаляет катлог из отслеживания (на жестком диске сохраняется)

git commit --ammend -m "комментарии"  - добавляет изменения к предыдущему коммиту и отражает комментарии

Зеркальный коммит отменить все изменения, которые внесли
git revert <index нужного коммита>

Чтобы НЕ коммитить мусорные файлы (временные с расширением tmp, db и т.д.) Специально создается файл
с расширением .gitignore в котором указываются типы файлов.
Этот файл тоже надо добавлять в проект и комитить.
git add .gitignore
git commit - m "add file .gitignore"


1. Создание удаленного репозитория (на ГитХабе)
Создаем на ГитХабе, клонируем к себе на компьютер, потом коммитим на локальном репозитории, и push-им на сервер гитхаба

Скопировать с удаленного репозитория на локальный используется команда  
git clone <url adress from GitHub repository>

Чтобы посмотреть какие внешние репозитории привязаны к нашему локальному используется команда
git remote -v

добавляем в папку с репозиторием и выполняем команду add

Локальный репозиторий можно отправить на удаленный ГитХаб
git push -u origin master
после ввода этой команды появится запрос о вводе ID and password от GitHub

2. Создал локальный репозиторий git init Далее решил его отправить на GitHub используется команда

git remote add <name (принято первым называть origin)> <url, который получили на github>

 после добавляем через команду git push -u origin master  и  get push


Лекция 3
Чтобы основной код работал, а в проекте исправлялись ошибки, добавлялись новые фичи и т.д.
создаются ветки проекта
команда для создания ветки - !внимание! остаешься работать на старой ветке, надо еще и перейти на новую
git branch <name_branch>

Для перехода на новую ветку используется команда
git checkout <name_branch>
git checkout --tarck<remote-branch(name)>  - после клонирования репозитория команда позволяет создать ветку уже у себя на локальном клоне.

Просмотр какие ветки есть исплользуют команду
git branch

Добавляя локальный репозиторий на сайт ГитХаб по умолчанию добавляется основная ветка  master, чтобы добавить созданную ветку
используют команду:
git push -u origin <name_branch>   -u  отражает имя ветки, в последующем достаточно просто писать git push
git push --all  - позволяетза пушить все ветки.


Для слияния веток переключаемся на основную ветку "мастер" и используем операцию merge
git checkout master <name example, master>
git merge --no--ff <name_branch>   --no--ff  - означает, что если не вносить комментарии, они все перейдут с изменениями новой ветки


git log --online --graph  - построит ветку изменений. если только интересует  информация по одной ветке, добавляют её имя


Ветки можно удалить ветку, если она не нужна
git branch -d <name_branch>  - local
git branch -delete origin <name_branch> - delete on GitHub



Теги в Гит используются для обозначения изменений, чтобы не запоминать номера репозиторий и ХешСуммы
Для присвоения тегов в локальной версии используется спец комманда, а для отправки на Гит Хаб явно указывается tag
git tag -a <name_tag> -m"comment" <commit-id>   -create tag on local
git tag -d <name_tag>   - delete tag on local

git push --tag <name_tag>     - create tag on GitHub
git push --delete <name_tag>   - delete tag on GitHub



Просмотр истории изменений

git log - работает с текущей веткой

git log --all  - выполняет поиск по всем веткам

git log  кто и когда внес изменения
git log --<name_file> просмотр по конкретному файлу
git show <cimmit_id or tag>--<name_file>  -изменения по конкретному коммиту и файлу
git log -p --<name_file>  - объединяет show and log история + сами изменения
git log --grep"message" -  осуществляет поиск по комментариям к комитам.
git log -S<"кусок кода"> -p  - осуществляет поиск по куску кода (были ли изменения с этим куском кода.
git blame --<nae_file or path>  - покажет имя и когда осуществлялись изменения по пути файла.


HEAD
Это указатель, который показывает в какой ветке находятся файл/файлы

git reset - позволяет передвигать указатель, эмулируя "отмену" коммита (коммит не исчезает, просто перемещается указатель)

есть режимы 
hard -передвигает указатель на нужный коммит, не сохраняя никаких изменений
soft -передвигает указатель на нужный коммит, при этом предыдущие изменения сохраняются в рабочем каталоге и индексе
mixed -передвигает указатель на нужный коммит, при этом предыдущие изменения сохраняются в рабочем каталоге, но не в индексе

git reset --<режим> <id cimmit>
git reset --<режим> HEAD <количество шагов >



Удаленные ветки

git checkout --track <name_branch>   позволяет склонировать удаленную ветку из удаленного репозитория. При стандартном клонировании, создается 

	только основная ветка, поэтому добавляем отдельные ветки.
(git clone <url from github>    склонирует репозиторий на локальный компьютер
 git branch			покажет ветки на локальном компьютере (будет основная ветка)
 git branch all			покажет все ветки, включая удаленного репозитория (узнали имя и командой ветку склонировали)


git fetch <origin>  забирает все изменения с удалённого сервера и сдвигает указатели удаленной ветки на нужные позиции
				fetch работает с теми ветками, с которыми сейчас работаем.

В случае возникновения конфликта в GIT используется след. фичи:
git fetch позволяет получить  НЕ модифицированные файлы с удаленного репозитория из working directory это позволит сделать 
слияние merge нормально. Получив их переходим на ветку и делаем merge


git pull  позволяет выполнить 2-а шага fetch + merge  за 1 шаг выкачиваем файл и переходим к процессу слияния, внося изменения


Issues
 функция позволяет сообшать об ошибках, общаться с разработчиками, ставить задачи, предлагать решения, задавать вопросы.
Гит позволяет хранить не только историю изменения кода, но и обсуждения, вопросы, предложения решения проблемы. ISSUE назначают
ответственного, к нему придет уведомление по нему он переходит в него и пишет что-то в ответ. 

Issue  можно закрыть на сайте ГитХаб. На специальном окне есть кнопка "Close issue". Второй способ закрыть, при исправлении кода
отправляем коммит и сразу спец. команду для закрытия Issue
git commit -a -m "fixes #2"   специальное слово fixes и  идентификатор  Issue "#2" закроют его


PULL REQUESTS
Т.к. все изменения в ГИТ происходят в отдельных ветках, разработчики не локально выполняют слияение. А делают запрос на изменен
после согласования уже делается merge

Two variant have:
Shared Repository -  когда вы являетесь участником репозитория и можете оставлять в нем коммиты

Fork and Pull - когда ты хочешь предложить изменения в чужом коде или не хочешь хранить исходные коды своего эксперимента
			в общем репозитории


base  - where we want to do Pull Requests
head - what we will transfer в качестве  Pull Requests










